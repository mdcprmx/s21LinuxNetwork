## Part 1. Инструмент ipcalc
- Поднимаю виртуалку **ws1**
- Устанавливаю ipcalc
    - **sudo apt install ipcalc**

- ### 1.1 Сети и маски:
    - **Определяю и пишу в отчёт:**

    1) Адрес сети **192.167.38.54/13**
        - Прожимаю **ipcalc 192.167.38.54/13** \
        ![p1 ipcalc basic](./pics/p1.png)

    2) Перевожу маску **255.255.255.0** в префиксную и двоичную запись:
        - Прожимаю **ipcalc 255.255.255.0** \
        - Префиксная /24
        - Двоичная 11111111.11111111.11111111.00000000 \
            ![p1 ipcalc 255](./pics/p2.png) \
             В префиксной записи маска этой подсети обозначается как **/24**

    - **/15** в обычную и двоичную:
        - Прожимаю **ipcalc 255.255.255.0/15**
        - 255.254.0.0 обычная
        - Двоичная 11111111.11111110.00000000.00000000 \
            ![p1 ipcalc 15](./pics/p3.png)
        

    - **11111111.11111111.11111111.11110000** в обычную и префиксную:
        - Прожимаю **ipcalc 255.255.255.0/28**
        - 255.255.255.240 обычная
        - Префиксная /28 \
        ![p1 ipcalc to 1111](./pics/p5.png)
    
    3) Минимальный и максимальный хост в сети **12.167.38.4** при:
        - При масках **/8**:
            - **ipcalc 12.167.38.4/8 | grep 'HostMin\|HostMax'** 
            - min 12.0.0.1
            - max 12.255.255.254 \
            ![p1 host 8](./pics/p6.png)

        - При маске **11111111.11111111.00000000.00000000**, тоесть префиксная **/16**:
            - **ipcalc 12.167.38.4/16 | grep 'HostMin\|HostMax'** 
            - min 12.167.0.1
            - max 12.167.255.254 \
            ![p1 host 16](./pics/p7.png)

        - При маске **255.255.254.0**:
            - **ipcalc 12.167.38.4 255.255.254.0 | grep 'HostMin\|HostMax'** 
            - min 12.167.38.1
            - max 12.167.39.254 \
            ![p1 host 254.0](./pics/p8.png)

        - И маске **/4**:
            - **ipcalc 12.167.38.4 255.255.254.0 | grep 'HostMin\|HostMax'** 
            - min 0.0.0.1
            - max 15.255.255.254 \
            ![p1 host 4](./pics/p9.png)

---
- ### 1.2 localhost
- Определяю можно ли обратиться к приложению работающему на localhost со следующими IP:

    - Если можно, то адреса будут находится в диапозоне **от 127.0.0.1 до 127.255.255.254** (HostMin/HostMax) 
    - **ipcalc 127.0.0.0 | grep 'HostMin\\|HostMax'** \
    ![p1 localhost](./pics/p12.png)
    
    - Можно ещё пингануть эти адреса: \
    ![p1 localhost ping](./pics/p13.png)
    
    - Итог:
        - 194.34.23.100 - нельзя
        - 127.0.0.2 - можно
        - 127.1.0.1 - можно
        - 128.0.0.1 - нельзя

---

- ### 1.3 Диапозоны и сегменты сетей

1) Какие IP можно использовать как публичные, а какие как частные?

    - Узнаём прожимая команду:
        - **ipcalc [address] | grep 'Hosts\Net'** \
        ![p1 hosts_net](./pics/p14.png)

        - 10.0.0.45 - частный
        - 134.43.0.2 - публичный
        - 192.168.4.2 - частный
        - 172.20.250.4 - частный
        - 172.0.2.1 - публичный
        - 192.172.0.1 - публичный
        - 172.68.0.2 - публичный
        - 172.16.255.255 - частный
        - 10.10.10.10 - частный
        - 192.169.168.1 - публичный
    
2) Какие IP адресов шлюза возможны у сети **10.10.0.0/18?**

- Узнаём через:
    - **ipcalc 10.10.0.0/18 | grep \HostMin\\|HostMax'** \
        ![p1 10.10](./pics/p16.png)
    - Доступный диапозон: **10.10.0.1 - 10.10.63.254**, тоесть:
        - 10.0.0.1 - нет, не возможен
        - 10.10.0.2 - да, возможен
        - 10.10.10.10 - да 
        - 10.10.100.1 - нет
        - 10.10.1.255 - да

## Part 2. Статическая маршрутизация между двумя машинами
- ### Поднимаю две виртуалки: **ws1 и ws2** 
    ![two vm](./pics/p17.png)

- ### Смотрю существующие сетвые интерфейсы
    - Через команду:
        - **ip a**
        - Вывод на **ws1**: \
        ![ip a screen ws1](./pics/p18.png)
        - Вывод на **ws2**: \
        ![ip a screen ws2](./pics/p19.png)

- ### Описываю сетевой интерфейc..
    - Задаю IP адреса и маски:
        - На **ws1**: 192.168.100.10/16 \
        ![p2 set IPnMask.ws1](./pics/p22.png)
        - На **ws2**: 172.24.116.8/12 \
        ![p2 set IPnMask.ws2](./pics/p24.png)

- ### Выполняю команду:
    - **netplan apply** \
    ![p2 netplan apply ws1](./pics/p25.png) \
    ![p2 netplan apply ws2](./pics/p26.png)
        - Без **sudo** не прожимается, по сему прожал с **sudo**
        

- ### 2.1 Добавление статического маршрута вручную

    - Добавляю статич маршрут туда и обратно через команду:
        - **ip r add** \
        ![p2.1 ip r add](./pics/p27.png) \
        ![p2.1 ip r add](./pics/p28.png)
    
    - Пингую соединение между машинами:
        - От **ws1** до **ws2**: \
        ![p2.1 ping](./pics/p32.png)
        - От **ws2** до **ws1**: \
        ![p2.1 ping](./pics/p33.png)


- ### 2.2. Добавление статического маршрута с сохранением
    - Ребутаю машины командой:
        - **sudo reboot**
    - Добавляю статический маршрут черех **.yaml** файл в **etc/netplan**:
        - Для **ws1**: \
        ![p2.2 yaml ws1](./pics/p34.png)
        - Для **ws2**: \
        ![p2.2 yaml ws2](./pics/p35.png)
    - Применяю netplan на обоих машинах через:
        - **sudo netplan try**
        - **sudo netplan apply**
    > **Важное замечание!** Перед началом этого таска (или перед пингом) надо в **настройках Virtual Box**, в настройках каждой машины выставить во вкладке **Network** Adapter на **Internal Network**, чтобы создать локальную сеть. 
    > - Получается установки такие:
    > - **Adapter 1** идёт **NAT**, (выход в сеть, интернет)
    > - **Adapter 2** идёт **Internal Network** (локалка, связь между машинами)
    > ![VM oracle net](./pics/p38.png)
    > - Соответственно и **yaml** файл меняется \
    >   - Для **ws1** \
    > ![yaml with 2 adapters ws1](./pics/p39.png)
    >   - Для **ws2** \
    > ![yaml with 2 adapters ws2](./pics/p40.png) \
    > Узнать корректный **enp0s** номер можно через **ip a** \
    > После этого будет и интернет и локалка! noice.

    - Пингую друг друга:
        - с **ws1** на **ws2** \
        ![p2 ping after yaml](./pics/p36.png)
        - с **ws2** на **ws1** \
        ![p2 ping after yaml](./pics/p37.png)

## Part 3. Утилита iperf3

- ### 3.1 Скорость соединения
- Бит(**bit**) это базовая единица измерения информации в digital мире. Один бит может иметь только два значения: 0 или 1.
- Байт(**byte**) состоит из 8 бит. Стандрат для измерения данных в digital, для измерения размера, обьёма памяти, и скорости передачи.
- Мегабайт(**MB**) состоит из 1 миллиона байт(6 нулей). Юзается много где
- Гигабайт(**GB**) состоит из 1 миллиарда байт (9 нулей)
- Есть ещё КилоБиты(**Kb**) и МегаБиты(**Mb**) которые основаны на битах (а не байтах)

    - Конвертирую:
        - 8 Mbps = 1 MB/s
        - 100 MB/s = 819200 Kbps
        - 1 Gbps = 1024 Mbps

- ### Утилита iperf3

- #### Чо эт ваще за утилита?
    - Эт кароч кроссплатформенная утилита, для измерения пропускной способности между двумя точками. Работает в режиме клиент-сервер, изза чего позволяет проверять в обоих направлениях.
        - Чтобы использовать эту утилиту, нужно установить её на обоих машинах, 
        - Затем одну машину запустить в режиме **сервера**
        - А другую в режиме **клиента**

- Измеряю скорость соединения между **ws1** и **ws2**
    - Запускаю **ws1** в режиме сервера через
        - **iperf -s** (надо будет apt install её тоже) \
            - **-s** в режиме сервера \
        ![iperf ws1 server](./pics/p42.png)
    - Коннектюсь к **ws1** через **ws2** юзая команду
        - **iperf -c 192.168.100.10** \
            - **-c** в режиме клиeнта \
        ![iperf ws2 connecting](./pics/p41.png) 
    - То же самое но в обратную сторону (от **ws1** коннект к **ws2**):  \
        ![iperf reverse](./pics/p43.png) 
- Скорость соединения соответственно:
    - **2.65Gbits/s** от ws1 к ws2
    - **2.62Gbits/s** от ws2 к ws1

## Part 4. Сетевой экран

- ### 4.1 Создаю имитацию фаерволла с правилами
    - Создаю файл **firewall.sh** в /etc/
    - Добавляю туда правила:
        - Запрещающее и разрешающее правило на **ws1** и **ws2**
        - Открываю на машинах доступ для порта **22(ssh)** и **80(http)**
        - Блокировка на OUTPUT
        - Разрешение на пингование
    - И надо заксриншотить содержимое **firewall.sh**:
        - **ws1** firewall.sh: \
        ![p4.1 firewall.sh ws1](./pics/p44.png)
        - **ws2** firewall.sh: \
        ![p4.1 firewall.sh ws2](./pics/p45.png)
    - Даю права на запуск через:
        - **chmod +x /etc/firewall.sh**
    - Запускаю имитацию фаерволла через:
        - **sudo bash /etc/firewall.sh**
    
    - Вывод этой команды скриншотю:
        - На **ws1**: \
        ![p4.1 sudo bash ws1](./pics/p46.png)
        - На **ws2**: \
        ![p4.1 sudo bash ws2](./pics/p47.png)
    
    - Разница между этими стратегиями? 
    - В том что очерёдность правил важна. На **первой** машине первым пройдёт правило на **DROP**, и оно применится. А на **второй** машине первым придёт правило **ACCEPT** и оно применится.

- ### 4.2 Утилита nmap
    - Ищу через **ping** то что не пингуется, затем через **nmap** показываю что хост запущен:
    - Скриншоты команд:
        - **ws1** пингую: \
        ![p4.2 ping](./pics/p48.png)
        - **ws1** nmap: \
        ![p4.2 nmap](./pics/p49.png)

        - **ws2** пингую: \
        ![p4.2 ping](./pics/p50.png)
        - **ws2** nmap: \
        ![p4.2 nmap](./pics/p51.png)

    - Сохранить дампы образов виртуальных машин..

## Part 5. Статическая маршрутизация сети

- Поднимаю **пять** виртуальных машин:
    - **три** рабочие станции
        - ws11
        - ws21
        - ws22
    - **два роутера**
        - r1
        - r2
-  По сути просто в Oracle Virtual Box жмакаю правой кнопкой на ВМ-ке и делаю клонирование машины три раза
    - Затем включаю каждую из них и через команды:
        - **sudo hostnamectl set-hostname %имя%**
        - **sudo reboot**
    - Ставлю им имена эти - **r1, r2, ws11, ws22, ws21**

- После этого настраиваю сетку между ними в Oracle Virtual Box через настройки каждой машины **(Settings -> Network)**:
    - **ws11**
        - Adapter 1 - **NAT**
        - Adapter 2 - **Internal Network, intnet_1**
    - **ws22**
        - Adapter 1 - **NAT**
        - Adapter 2 - **Internal Network, intnet_3**
    - **ws21**
        - Adapter 1 - **NAT**
        - Adapter 2 - **Internal Network, intnet_3**
    - **r1**
        - Adapter 1 - **NAT**
        - Adapter 2 - **Internal Network, intnet_1**
        - Adapter 3 - **Internal Network, intnet_2**
    - **r2**
        - Adapter 1 - **NAT**
        - Adapter 2 - **Internal Network, intnet_2**
        - Adapter 3 - **Internal Network, intnet_3**

- ### 5.1 Настройка адресов машин

- Отчёт со скринами содержимого **etc/netplan/00-installer-config.yaml** файлика:
    - **r1** \
    ![yaml pic](./pics/p53.png)
    - **r2** \
    ![yaml pic](./pics/p54.png)
    - **ws11** \
    ![yaml pic](./pics/p55.png)
    - **ws22** \
    ![yaml pic](./pics/p56.png)
    - **ws21** \
    ![yaml pic](./pics/p57.png)

- Перезапускаю сервис сети через
    - **sudo netplan try**
    - **sudo netplan apply**

- Проверяю что всё задано верно через команду 
    - **ip -4 a**

- И вывожу скрины с выводом **ip -4 a**:
    - **ws11** \
    ![ip4a ws11](./pics/ipa1.png)
    - **ws21** \
    ![ip4a ws21](./pics/ipa2.png)
    - **ws22** \
    ![ip4a ws22](./pics/ipa3.png)
    - **r1** \
    ![ip4a ws11](./pics/ipa4.png)
    - **r2** \
    ![ip4a ws11](./pics/ipa5.png)

    - Адреса получились такие:
        - ws11 - 10.10.0.2
        - ws21 - 10.20.0.10
        - ws22 - 10.20.0.20
        - r1 два адреса так как он соединяет две сетки
            - 10.10.0.1
            - 10.100.0.11
        - r2 тож роутер поэтому два адреса
            - 10.100.0.12 
            - 10.20.0.1

- Затем скрины с пингом:
    - Пинг с **ws22** на **ws21**: \
    ![from ws22 to ws21](./pics/ipa6.png)

    - Пинг с **r1** на **ws11**: \
    ![from r1 to ws11](./pics/q1.png)

- ### 5.2 Включение переадресации IP-адресов

- Прожимаю команду на **r1** и **r2**
    - **sudo sysctl -w net.ipv4.ip_forward=1**

- Скриншот с выводом команды: \
    ![sysctl forwards](./pics/q2.png)

- Постоянная переадресация через файл */etc/sysctl.conf*
    - И добавление в него строки:
        - **`net.ipv4.ip_forward = 1`**

    - На **r1**: \
    ![ipv4_forward](./pics/q3.png)
    - На **r2**: \
    ![ipv4_forward](./pics/q4.png) \
    > По сути прост раскомментил одну строчку в файле, там уже всё было

- ### 5.3 Установка маршрута по умолчанию

- Настраиваю машрут по умолчанию (gateway) для **ws11, ws21, ws22**
    - Через наш любимый **yaml** файлик:
        - **ws11** \
        ![gateway add](./pics/q5.png)
        - **ws21** \
        ![gateway add](./pics/q6.png)
        - **ws22** \
        ![gateway add](./pics/q7.png)

- Также вот состояние r1 и r2:
    - **r1:** \
    ![r1 yaml state](./pics/q11.png)
    - **r2:** \
    ![r2 yaml state](./pics/q12.png)
    > Только так смог сделать чтоб пинговался **r2** с **ws11**

- Прожимаю ip r и показываю что наш гейтвэй добавлен:
    - Команда **ip r | grep default**
    - (хотя кжс можно и не грэпать)
        - **ws11** \
        ![gateway add](./pics/q8.png)
        - **ws21** \
        ![gateway add](./pics/q9.png)
        - **ws22** \
        ![gateway add](./pics/q10.png)

- Теперь всё это дело пингуем:
    - Вывод на **r2** с командой 
        - **sudo tcpdump -tn -i enp0s8** \
        ![tcpdump r2](./pics/q14.png)
        - Вывод пинга идущего с **ws11:** \
        ![tcpdump ws11 ping](./pics/q13.png)

- ### 5.4 Добавление статических маршрутов

- Добавляю в роутеры статические маршруты в yaml.
    - yaml файлик на **r1**: \
    ![5.4 yaml state](./pics/q15.png)
    - yaml файлик на **r2**: \
    ![5.4 yaml state](./pics/q16.png)

- Вызываю **ip r**
    - Скриншот с **r1** \
    ![5.4 r1 screenshot](./pics/q17.png) 
    - Скриншот с **r2** \
    ![5.4 r1 screenshot](./pics/q18.png)

- Запускаю команды на **ws11** \
    - **ip r list 10.10.0.0/18** 
    - **ip r list 0.0.0.0/0** \
    ![5.4 ip r list](./pics/q20.png) 

- Почему для адреса **10.10.0.0/18** был выбран маршурт отличный от 0.0.0.0/0?
    - Потомучто он более низкий по приоритету
    - И потомучто при наличии нескольких маршрутов одинаковой длинны выбирается тот который задан точно 

- ### 5.5 Построение списка маршрутизаторов

- Запускаю на **r1** команду:
    - **sudo tcpdump -tnv -i enp0s8**

- Затем трэйсрутаю с **ws11** до **ws21**
    - **sudo traceroute 10.20.0.10** 
    - (кстати traceroute ещё установить надо) \
    ![5.5 traceroute](./pics/q51.png)
    - И получаю дамп на **r1** \
    ![5.5 tcpdump](./pics/q22.png)

- Traceroute использует UDP-пакеты для определения пути к целевому хосту, отправляя их с увеличивающимся значением TTL. При этом, каждый пакет направляется на порт, который по умолчанию равен 34434, но может быть изменен. Когда пакет достигает целевого хоста, хост отправляет сообщение об ошибке "Destination port unreachable", что указывает на успешное получение пакета. Это позволяет Traceroute определить, что пакет достиг цели, и завершить трассировку.

- ### 5.6 Использование протокола ICMP при маршрутизации

- Запускаю на **r1** перехват сетевого трафика проходящего через enp0s8:
    - Прожимаю команду
        - **sudo tcpdump -n -i enp0s8 icmp** \
        ![5.6 tcpdump icmp](./pics/q24.png)
        - Пингую на **ws11** несуществующий IP: \
        ![5.6 ping](./pics/q23.png)

## Part 6. Динамическая настройка IP с помощью **DHCP**

- Сначала кстати надо будет установить **dhcp** через:
    - **sudo apt install isc-dhcp-server**

- 1) Указываю адрес машрутизатора по умолчанию, DNS, и адрес внутренней сети для **r2** \
![6 dhcp](./pics/q25.png)

- 2) В файле /etc/resolv.conf пишу **nameserver 8.8.8.8** \
![6 resolv](./pics/q26.png)

    - Перезагружаю DHCP командой:
        - **systemctl restart isc-dhcp-server** \
        ![p6 dhcp restart](./pics/q52.png)
        > Кстати срабатывает только после ребута ВМки

    - Машину **ws21** ребутаю и прожимаю **ip a** \
    ![p6 ip a](./pics/q28.png)

    - Затем отправляю пинг с **ws21** на **ws22** \
    ![p6 ping](./pics/p29.png)

- Указываю MAC адрес у **ws11**
    - В нашем любимом **yaml** файле: \
    ![p6 mac add](./pics/q30.png)
    - И в настройках **VM Oracle**
    ![p6 VM oracle](./pics/q65.png)

- Настраиваю **r1** аналогично **r2**
    - **dhcpd.conf:** \
    ![p6 dhcpd r1](./pics/q31.png)
    - Ребутаю DHCP: \
    ![p6 dhcp rebot](./pics/q32.png)

- Аналогичный тест на **ws11**
    - **ip a** \
    ![p6 scnd test](./pics/q33.png)
    - И пингуем: \
    ![p6 ping test](./pics/q34.png) 

- Запрашиваю обновление IP адреса с **ws21**
    - Запрашиваю обновления командой **sudo dhclient enp0s8** \
    ![p6 request](./pics/q35.png)

    - #### До обновы: 
    ![p6 before](./pics/q28.png)
    - #### После обновления: 
    ![p6 after](./pics/q64.png)


- Какие опиции **DHCP** я юзал в данном пунтке?
    - **sudo dhclient -r enp0s3** для того чтоб освободить текущий интерфейс
    - **sudo dhclient enp0s3** для того чтоб задать новый адрес указанному интерфейсу

- ## Part 7. NAT
- Сначала надо установить apache2
    - **sudo apt install apache2**

- Если инета нет, то в yaml файле меняешь dhcp с false на true или выключаешь уже включенный dhcp (ну или прост вырубаешь в настройках ВМ)

- Меняю строку в файле **/etc/apache2/ports.conf**
    - На **ws22:** \
    ![p7 ws22](./pics/q37.png)

    - И на **r1** \
    ![p7 r1](./pics/q38.png)

- Запускаю apache на **ws22** и **r1**
    - **service apache2 start**
        - **ws22** \
        ![p7 apache start](./pics/q39.png)
        - **r1** \
        ![p7 apache start](./pics/q40.png)

- Добавляю в фаерволл из **Part 4** на **r2** следующие правила:
    - Удаление правил в таблице **filter - iptables -F;**

    - Удаление правил в таблице "NAT" - **iptables -F -t nat;**

    - Отбрасывать все маршрутизируемые пакеты - **iptables --policy FORWARD DROP**

- В результате **firewall.sh** на машине **r2** выглядит таким образом: \
    ![p7 firewall](./pics/q56.png)
    - Затем даём ему права запуска, и запускаем его командами:
        - **sudo chmod +x firewall.sh** 
        - **sudo bash firewall.sh** \
        ![p7 firewall ON](./pics/q54.png)
        - Командой **sudo iptables -L** проверяем какие правила включены

- Пингую **r1** с **ws22** \
    ![p7 ping](./pics/q43.png) \
    ![p7 ping 2](./pics/q53.png) 

- Подключаюсь к серверу apache2 с **r1** на **ws22** \
    ![p7 telnet from r1](./pics/q57.png)

- Подключаюсь наоборот, от **ws22** к **r1** \
    ![p7 telnet from ws22](./pics/q47.png)

- ## Part 8. Дополнительно. Знакомство с SSH Tunnels

- #### Запускаю **firewall.sh** из части 7 на **r2**
    - **sudo bash /etc/firewall.sh** \
    -![p8 firewall start](./pics/q59.png)


- #### Запускаю веб-сервер Apache

    - Сначала меняю в **etc/apache2/ports.conf** на **ws22** строчку:
        - **Listen 80**
        - на строчку
        - **Listen localhost:80** \
        ![p8 conf](./pics/q58.png)

    - Затем прожимаю **service apache2 start**

    - На каждой из машин **ws11, ws22, ws21**:
        - В файле etc/ssh/sshd_config:
            - Раскомменчиваем:
                - **Port 22**
                - **ListenAddress 0.0.0.0**
                - **ListenAddress : :**
        
        ![p8 sshd_config](./pics/q60.png)
        ![p8 sshd_config](./pics/q61.png)
        ![p8 sshd_config](./pics/q62.png)

    - Запускаем **sshd** на трёх машинах, используя:
        - **sudo systemctl restart sshd**
        - **sudo systemctl status sshd**
            - На **ws22** \
            ![p8 sshd init](./pics/q67.png)

            - На **ws11** \
            ![p8 sshd init](./pics/q68.png)

            - И на **ws21** \
            ![p8 sshd init](./pics/q69.png)

- #### Прожимаю подключение по **SSH**:
    - Тип соединения **Local TCP forwarding**: с машины **ws21** на **ws22**
    - Используя команду:
        - **ssh -L 8888:10.20.0.20:80 10.20.0.20**
        ![p8 ssh connect](./pics/q70.png)

    - Тип соединения **Remote TCP forwarding**: с машины **ws11** до **ws22**
        - Используя команду:
        - **ssh -R 8888:10.20.0.20:80 10.20.0.20**
        - Но так сразу не получится, сначало нужно в **firewall.sh** черещ **iptables** создать новые правила переадресации, на машине **r2**
            - Дополненный **firewall.sh** на **r2**
            ![p8 r2 firewall.sh](./pics/q71.png)
            - Что за синтаксис?
                - **iptables** утилита для контроля фаервола
                - **-A** append, добавляет правило для переадресации
                - **-p tcp** protocol, определяет протокол (TCP)
                - **-m multiport** добавляет несколько портов за один раз
                - **--dports 80,22,8080** destination ports, определяет порты назначения.
                    - 80 - это порт HTTP
                    - 22 - порт SSH
                    - 8080 отдельный который мы сами выделили для подключения
                - **--sports** source ports, указывает по каким портам источникам фильтровать
                - **-j ACCEPT** jump taget, указывает что данные пакеты должны пройти по пути
            
            - Запускаю и проверяю **firewall.sh**
            ![p8 r2 iptables -L](./pics/q72.png)

- И теперь прожимаем:
    - **ssh -R 8888:10.20.0.20:80 10.20.0.20**
    ![p8 ssh R](./pics/q73.png)
    - Соединение установилось..

- #### Теперь проверяем сработало ли подключение:
    - Через команду **telnet 127.0.0.1 80** 
    - Во втором окне машины на **ws22** (нажатием **Win + F2**) \
    ![p8 telnet](./pics/q74.png)

- Всё ок.
